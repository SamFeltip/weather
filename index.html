<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Weather</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Bitcount+Grid+Double:wght@100..900&family=Figtree:ital,wght@0,300..900;1,300..900&family=Geist:wght@100..900&family=Unbounded:wght@200..900&display=swap"
      rel="stylesheet"
    />
    <style>
      #current-weather {
        position: absolute;
        top: 16px;
        left: 16px;
        gap: 4px;
        display: flex;
        align-items: center;
        color: white;
        font-family: "Figtree";
        font-size: 20px;

        & svg {
          width: 54px;
          height: 54px;
          margin-bottom: 10px;
        }

        #current-temp {
          margin-bottom: 16px;
        }
      }

      .weather-wrapper {
        position: relative;
        height: 100%;
      }

      /* both stacked in same place */
      .last-weather,
      .next-weather {
        position: absolute;
        inset: 0;
        transition:
          opacity 0.2s ease,
          visibility 0.2s ease;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
      }

      /* visible states */
      .show-last-weather .last-weather {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      .show-next-weather .next-weather {
        opacity: 1;
        visibility: visible;
        pointer-events: auto;
      }

      #rain-timeline {
        .graph {
          position: relative;
          /* width: 100%; */
          display: flex;
          justify-content: space-between;
          align-items: center;
          box-sizing: border-box;
        }

        .baseline {
          position: absolute;
          top: 50%;

          width: 100%;
          height: 1.2px;
          background: rgb(88, 155, 208);
          /* opacity: 0.4; */
          transform: translateY(-50%);
          border-radius: 5px;
          z-index: 1;
        }

        .hour-marker {
          position: absolute;
          left: calc(var(--hour-position) / 16 * 100%);
          width: 1.3px;
          border-radius: 5px;
          height: 40px;
          background: white;
          /* opacity: 0.4; */
          transform: translateX(-50%) translateY(-50%);
          z-index: 1;

          /* add a ball to the bottom of the hour market */
          &::before {
            content: "";
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 5px;
            height: 5px;
            background: white;
            border-radius: 50%;
          }
        }

        .column {
          position: relative;
          width: 12px;
          margin-inline: 2px;
          height: 100%;
          display: flex;
          justify-content: center;
          border-radius: 5px;

          line-height: calc(var(--top-height) * 2 + 12px);
          font-size: 0.5rem;
          text-align: center;
          font-family: "Figtree";

          &::before {
            border-radius: 0px 0px 15px 15px;
          }

          &::after {
            border-radius: 15px 15px 0px 0px;
          }
        }

        /* Top bar */
        .column::after {
          content: "";
          color: white;
          position: absolute;
          bottom: 50%;
          width: 100%;
          height: var(--top-height, 0px);
          background: #bbdefb;
          transform-origin: bottom;
          transition: height 0.3s ease;
        }

        /* Bottom bar */
        .column::before {
          content: "";
          position: absolute;
          top: 50%;
          width: 100%;
          height: var(--bottom-height, 0px);
          background: #1e88e5;
          transform-origin: top;
          transition: height 0.3s ease;
        }

        .column:nth-child(3n)::after {
          content: attr(data-index);
        }
      }
    </style>
  </head>
  <body
    class="show-last-weather"
    style="
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(to bottom, #4fc3f7, #81d4fa);
    "
  >
    <div id="current-weather" style="display: none">
      <!-- <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 640">
        <path
          d="M320 64C214 64 128 148.4 128 252.6C128 371.9 248.2 514.9 298.4 569.4C310.2 582.2 329.8 582.2 341.6 569.4C391.8 514.9 512 371.9 512 252.6C512 148.4 426 64 320 64z"
        />
      </svg> -->
      <svg id="current-weather-icon"></svg>
      <span id="current-temp">
        <span id="current-temp-content"></span>&deg;C
      </span>
    </div>

    <div id="rain-timeline" style="visibility: hidden; padding-top: 120px">
      <div class="graph">
        <div class="baseline"></div>
        <div class="hour-marker"></div>
        <div class="column" data-index="6"></div>
        <div class="column" data-index="7"></div>
        <div class="column" data-index="8"></div>
        <div class="column" data-index="9"></div>
        <div class="column" data-index="10"></div>
        <div class="column" data-index="11"></div>
        <div class="column" data-index="12"></div>
        <div class="column" data-index="13"></div>
        <div class="column" data-index="14"></div>
        <div class="column" data-index="15"></div>
        <div class="column" data-index="16"></div>
        <div class="column" data-index="17"></div>
        <div class="column" data-index="18"></div>
        <div class="column" data-index="19"></div>
        <div class="column" data-index="20"></div>
        <div class="column" data-index="21"></div>
      </div>
    </div>
    <div
      id="weatherGrid"
      style="
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto;
        align-items: center;
        gap: 3.5rem;
        padding: 3rem;
      "
    >
      <svg
        id="rain"
        width="120"
        height="120"
        viewBox="0 0 64 64"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <g fill="#bbdefb">
          <circle cx="32" cy="24" r="13" />
          <circle cx="18" cy="32" r="10" />
          <circle cx="46" cy="32" r="10" />
          <rect x="18" y="30" width="28" height="12" />
        </g>

        <line
          x1="24"
          y1="48"
          x2="20"
          y2="58"
          stroke="#1e88e5"
          stroke-width="4"
          stroke-linecap="round"
        />
        <line
          x1="36"
          y1="50"
          x2="32"
          y2="60"
          stroke="#1e88e5"
          stroke-width="4"
          stroke-linecap="round"
        />
        <line
          x1="48"
          y1="48"
          x2="44"
          y2="58"
          stroke="#1e88e5"
          stroke-width="4"
          stroke-linecap="round"
        />
      </svg>
      <span id="rain-weather" class="weather-wrapper"></span>
      <svg id="snow" width="120" height="120" viewBox="0 0 64 64" fill="none">
        <circle cx="32" cy="32" r="5" fill="#e3f2fd" />
        <g stroke="#e3f2fd" stroke-width="4">
          <line x1="32" y1="8" x2="32" y2="56" />
          <line x1="8" y1="32" x2="56" y2="32" />
          <line x1="18" y1="18" x2="46" y2="46" />
          <line x1="46" y1="18" x2="18" y2="46" />
        </g>
      </svg>
      <span id="snow-weather" class="weather-wrapper"></span>
      <svg
        id="sunshine"
        width="120"
        height="120"
        viewBox="0 0 64 64"
        fill="none"
      >
        <circle cx="32" cy="32" r="14" fill="#ffeb3b" />
        <g stroke="#fbc02d" stroke-width="4">
          <line x1="32" y1="2" x2="32" y2="16" />
          <line x1="32" y1="48" x2="32" y2="62" />
          <line x1="2" y1="32" x2="16" y2="32" />
          <line x1="48" y1="32" x2="62" y2="32" />
          <line x1="12" y1="12" x2="22" y2="22" />
          <line x1="42" y1="42" x2="52" y2="52" />
          <line x1="42" y1="22" x2="52" y2="12" />
          <line x1="12" y1="52" x2="22" y2="42" />
        </g>
      </svg>
      <span id="sun-weather" class="weather-wrapper"></span>
      <svg
        id="clouds"
        width="120"
        height="120"
        viewBox="0 0 64 64"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <g fill="#bbdefb">
          <circle cx="32" cy="24" r="13" />
          <circle cx="18" cy="32" r="10" />
          <circle cx="46" cy="32" r="10" />
          <rect x="18" y="30" width="28" height="12" />
        </g>
      </svg>
      <span id="cloud-weather" class="weather-wrapper"></span>
    </div>

    <script>
      //@ts-check

      // Clear skies
      const CLEAR = 0;
      const MAINLY_CLEAR = 1;

      // Partly cloudy / overcast
      const PARTLY_CLOUDY = 2;
      const OVERCAST = 3;

      // Rain / Showers
      const DRIZZLE_LIGHT = 51;
      const DRIZZLE_MODERATE = 53;
      const DRIZZLE_HEAVY = 55;
      const RAIN_LIGHT = 61;
      const RAIN_MODERATE = 63;
      const RAIN_HEAVY = 65;
      const SHOWERS_SLIGHT = 80;
      const SHOWERS_MODERATE = 81;
      const SHOWERS_VIOLENT = 82;

      // Snow / Snow Showers
      const SNOW_LIGHT = 71;
      const SNOW_MODERATE = 73;
      const SNOW_HEAVY = 75;
      const SNOW_GRAINS = 77;
      const SNOW_SHOWERS_SLIGHT = 85;
      const SNOW_SHOWERS_HEAVY = 86;

      const LATITUDE = 53.3676;
      const LONGITUDE = -1.5023;

      const MS_PER_DAY = 1000 * 60 * 60 * 24;

      /**
       * @typedef {Object.<number, number>} WeatherThresholds
       */

      /** @type {WeatherThresholds} */
      const WEATHER_THRESHOLDS = {
        [CLEAR]: 3,
        [MAINLY_CLEAR]: 4,
        [PARTLY_CLOUDY]: 6,
        [OVERCAST]: 5,
        [DRIZZLE_LIGHT]: 4,
        [DRIZZLE_MODERATE]: 4,
        [DRIZZLE_HEAVY]: 4,
        [RAIN_LIGHT]: 5,
        [RAIN_MODERATE]: 5,
        [RAIN_HEAVY]: 3,
        [SHOWERS_SLIGHT]: 3,
        [SHOWERS_MODERATE]: 2,
        [SHOWERS_VIOLENT]: 2,
        [SNOW_GRAINS]: 4,
        [SNOW_LIGHT]: 4,
        [SNOW_MODERATE]: 3,
        [SNOW_HEAVY]: 1,
        [SNOW_SHOWERS_SLIGHT]: 2,
        [SNOW_SHOWERS_HEAVY]: 2,
      }; // minimum number of hours in a day with the weather code to count as an occurrence

      const RAIN_THRESHOLD = 1; // in mm
      const SNOW_THRESHOLD = 0.1; // in cm

      /**
       * @typedef {{ diff: number, date: Date }} WeatherOccurrence
       */

      /**
       * @typedef {{ last: WeatherOccurrence | null, next: WeatherOccurrence | null }} WeatherResult
       */

      /**
       * @typedef {{
       *   elemId: string,
       *   codes: number[]
       * }} WeatherTypeConfig
       */

      /**
       * @typedef {{
       *   time: string[],
       *   weather_code: number[],
       *   temperature_2m: number[],
       *   rain: number[],
       *   showers: number[],
       *   snowfall: number[],
       *   snow_depth: number[],
       *   cloud_cover_low: number[],
       *   cloud_cover_mid: number[],
       *   cloud_cover_high: number[]
       * }} HourlyData
       */

      /**
       * @typedef {{
       *   time: string[],
       *   rain_sum: number[],
       *   showers_sum: number[],
       *   snowfall_sum: number[],
       *   precipitation_sum: number[]
       * }} DailyData
       */

      /**
       * @typedef {{
       *   hourly: HourlyData,
       *   daily: DailyData
       * }} ForecastResponse
       */

      /** @type {{ rain: WeatherTypeConfig, snow: WeatherTypeConfig, sunshine: WeatherTypeConfig, clouds: WeatherTypeConfig }} */
      const weatherTypes = {
        rain: {
          elemId: "rain-weather",
          codes: [
            DRIZZLE_LIGHT,
            DRIZZLE_MODERATE,
            DRIZZLE_HEAVY,
            RAIN_LIGHT,
            RAIN_MODERATE,
            RAIN_HEAVY,
            SHOWERS_SLIGHT,
            SHOWERS_MODERATE,
            SHOWERS_VIOLENT,
            SNOW_SHOWERS_SLIGHT,
            SNOW_SHOWERS_HEAVY,
          ],
        },
        snow: {
          elemId: "snow-weather",
          codes: [
            SNOW_LIGHT,
            SNOW_MODERATE,
            SNOW_GRAINS,
            SNOW_HEAVY,
            SNOW_SHOWERS_SLIGHT,
            SNOW_SHOWERS_HEAVY,
          ],
        },
        sunshine: {
          elemId: "sun-weather",
          codes: [CLEAR, MAINLY_CLEAR],
        },
        clouds: {
          elemId: "cloud-weather",
          codes: [PARTLY_CLOUDY, OVERCAST],
        },
      };

      /**
       * @param {string} key
       * @param {Date} date
       * @returns {string}
       */
      function getHumanReadableTimePeriod(key, date) {
        const today = new Date();
        const diff = Math.floor(
          (today.getTime() - date.getTime()) / MS_PER_DAY,
        );
        if (diff === 0) return `${key} earlier today`;
        if (diff === 1) return `${key} yesterday`;
        if (diff < 7) return `${key} ${diff} days ago`;
        if (diff == 7) return `${key} last week`;
        if (diff < 60) return `${key} ${Math.floor(diff / 7)} weeks ago`;

        return `${key} ${Math.floor(diff / 30)} months ago`;
      }

      /**
       * @param {string} weatherType
       * @param {WeatherOccurrence | null} nextData
       * @returns {string}
       */
      function getHumanReadableFutureDate(weatherType, nextData) {
        if (!nextData) return `no ${weatherType} for a while`;

        const { diff } = nextData;
        if (diff === 0) return `${weatherType} later today`;
        if (diff === 1) return `${weatherType} tomorrow`;
        if (diff < 7) return `${weatherType} in ${diff} days`;
        if (diff == 7) return `${weatherType} next week`;
        if (diff < 60) return `${weatherType} in ${Math.floor(diff / 7)} weeks`;

        return `${weatherType} in ${Math.floor(diff / 30)} months`;
      }

      /**
       * @param {string} elemId
       * @param {string} key
       * @param {WeatherResult} data
       * @returns {void}
       */
      function createCell(elemId, key, data) {
        const elem = document.getElementById(elemId);
        if (!elem) {
          console.warn(`[Weather] Element with ID '${elemId}' not found`);
          throw new Error(`Element with ID '${elemId}' not found`);
        }

        elem.innerHTML = `
            <span class="last-weather">
          ${
            data?.last
              ? `
          <h2 style="line-height:0.8;padding-block-start:1.7rem;margin:0;text-align:center;font-size:72px;font-weight:300;color:white;font-family: Bitcount Grid Double;">${data.last.diff}</h2>
              <p style="margin:0;margin-bottom:12px;font-family:Figtree;color:white;text-align:center;opacity: 0.65;">${getHumanReadableTimePeriod(key, data.last.date)}</p>
              `
              : `
              <h2 style="margin:0;text-align:center;font-size:72px;font-weight:300;color:white;font-family: Bitcount Grid Double;">unknown</h2>
              `
          }
            </span>
            <span class="next-weather">
              <h2 style="line-height:0.8;padding-block-start:1.7rem;margin:0;text-align:center;font-size:72px;font-weight:300;color:white;font-family: Bitcount Grid Double;">${data?.next?.diff ?? "n/a"}</h2>
              <p style="margin:0;font-family:Figtree;color:white;text-align:center;opacity: 0.65;">${getHumanReadableFutureDate(key, data.next)}</p>
            </span>

      `;
      }

      /**
       * @returns {Promise<ForecastResponse | null>}
       */
      async function fetchRange() {
        const hourly_params = ["weather_code"];
        const daily_params = [
          "rain_sum",
          "showers_sum",
          "snowfall_sum",
          "precipitation_sum",
        ];

        const url = new URL("https://api.open-meteo.com/v1/forecast");
        url.search = new URLSearchParams({
          latitude: LATITUDE.toString(),
          longitude: LONGITUDE.toString(),
          hourly: hourly_params.join(","),
          daily: daily_params.join(","),
          past_days: "60",
          forecast_days: "16",
          timezone: "auto",
        }).toString();

        console.log("[Weather] Request URL:", url);

        try {
          const res = await fetch(url);
          if (!res.ok) return null;
          /** @type {ForecastResponse} */
          const data = await res.json();
          if (!data || !data.hourly || !data.hourly.time) return null;
          return data;
        } catch (err) {
          console.log("[Weather] API error:", err);
          return null;
        }
      }

      /**
       * @returns {Promise<void | null>}
       */
      async function fetchWeather() {
        const today = new Date();
        const maxLookbackDays = 365 * 5;

        /** @type {{ [K in keyof typeof weatherTypes]: WeatherResult }} */
        const results = {
          rain: { last: null, next: null },
          snow: { last: null, next: null },
          sunshine: { last: null, next: null },
          clouds: { last: null, next: null },
        };

        const data = await fetchRange();
        if (!data) {
          return null;
        }

        const hours = data.hourly.time.map((t) => new Date(t));
        const codes = data.hourly.weather_code;
        const days = data.daily.time.map((t) => new Date(t));

        for (const key in weatherTypes) {
          console.debug(`[Weather] ${key}`);

          const dailyData = days.map((day, index) => ({
            date: day,
            rain: data.daily.rain_sum[index] || 0,
            showers: data.daily.showers_sum[index] || 0,
            snow: data.daily.snowfall_sum[index] || 0,
          }));

          /** @type {{ [day: string]: { [code: number]: number } }} */
          const dailyCounts = {};

          hours.forEach((hour, index) => {
            const dayKey = hour.toISOString().split("T")[0];
            if (!dailyCounts[dayKey]) dailyCounts[dayKey] = {};

            const code = codes[index];
            if (!dailyCounts[dayKey][code]) dailyCounts[dayKey][code] = 0;
            dailyCounts[dayKey][code]++;
          });

          for (const daily of dailyData.reverse()) {
            const dayKey = daily.date.toISOString().split("T")[0];
            const isRainy =
              key === "rain" && daily.rain + daily.showers >= RAIN_THRESHOLD;
            const isSnowy = key === "snow" && daily.snow >= SNOW_THRESHOLD;
            const isSunny =
              key === "sunshine" &&
              weatherTypes[key].codes.some(
                (code) => dailyCounts[dayKey]?.[code],
              );
            const isCloudy =
              key === "clouds" &&
              weatherTypes[key].codes.some(
                (code) => dailyCounts[dayKey]?.[code],
              );

            if (isRainy || isSnowy || isSunny || isCloudy) {
              const lastDate = daily.date;
              const diff = Math.floor(
                (today.getTime() - lastDate.getTime()) / MS_PER_DAY,
              );

              if (diff < 0) {
                continue;
              }

              console.debug(
                `[Weather] Found last ${key} on ${lastDate.toISOString().split("T")[0]} (${diff} days ago)`,
              );
              results[key].last = { diff, date: lastDate };
              break;
            }
          }

          for (const daily of dailyData.reverse()) {
            const dayKey = daily.date.toISOString().split("T")[0];
            const isRainy =
              key === "rain" && daily.rain + daily.showers >= RAIN_THRESHOLD;
            const isSnowy = key === "snow" && daily.snow >= SNOW_THRESHOLD;
            const isSunny =
              key === "sunshine" &&
              weatherTypes[key].codes.some(
                (code) => dailyCounts[dayKey]?.[code],
              );
            const isCloudy =
              key === "clouds" &&
              weatherTypes[key].codes.some(
                (code) => dailyCounts[dayKey]?.[code],
              );

            if (isRainy || isSnowy || isSunny || isCloudy) {
              const nextDate = daily.date;
              const diff = Math.floor(
                (nextDate.getTime() - today.getTime()) / MS_PER_DAY,
              );

              if (diff < 0) {
                continue;
              }

              console.debug(
                `[Weather] Found next ${key} on ${nextDate.toISOString().split("T")[0]} (in ${diff} days)`,
              );
              results[key].next = { diff, date: nextDate };
              break;
            }
          }
        }

        Object.entries(weatherTypes)
          .map(([key, val]) => createCell(val.elemId, key, results[key]))
          .join("");
      }

      /**
       * @returns {Promise<HourlyData>}
       */
      async function fetchCurrentWeather() {
        const hourly_params = [
          "temperature_2m",
          "weather_code",
          "rain",
          "showers",
          "snowfall",
          "snow_depth",
          "cloud_cover_low",
          "cloud_cover_mid",
          "cloud_cover_high",
        ];

        const params = new URLSearchParams({
          latitude: LATITUDE.toString(),
          longitude: LONGITUDE.toString(),
          hourly: hourly_params.join(","),
          forecast_days: "1",
        });

        const url = new URL("https://api.open-meteo.com/v1/forecast");
        url.search = params.toString();

        console.debug("[Weather] Fetching current weather:", url.toString());

        const res = await fetch(url);
        if (!res.ok) {
          console.error("Failed to fetch current weather:", res.statusText);
          throw new Error(`Failed to fetch current weather: ${res.statusText}`);
        }

        /** @type {{ hourly: HourlyData }} */
        const data = await res.json();

        if (
          !data ||
          !data.hourly ||
          !data.hourly.time ||
          !data.hourly.weather_code ||
          !data.hourly.temperature_2m
        ) {
          console.error("Invalid weather data format");
          throw new Error("Invalid weather data format");
        }

        return data.hourly;
      }

      const MAX_BAR_HEIGHT = 30; // in pixels

      /**
       * @param {number} index
       * @param {number} height as a %
       * @returns {void}
       */
      function setTopBar(index, height) {
        /** @type {HTMLElement?} */
        const column = document.querySelector(
          `#rain-timeline .column[data-index="${index}"]`,
        );
        if (!column) {
          return;
        }

        if (height === 0) {
          column.style.removeProperty("--top-height");
          return;
        }

        const heightPx = `${Math.max(2, Math.floor(MAX_BAR_HEIGHT * height))}px`;
        column.style.setProperty("--top-height", heightPx);
      }

      /**
       * @param {number} index
       * @param {number} height as a %
       * @returns {void}
       */
      function setBottomBar(index, height) {
        /** @type {HTMLElement?} */
        const column = document.querySelector(
          `#rain-timeline .column[data-index="${index}"]`,
        );
        if (!column) {
          return;
        }

        if (height === 0) {
          column.style.removeProperty("--bottom-height");
          return;
        }

        const heightPx = `${Math.max(Math.floor(MAX_BAR_HEIGHT * height), 2)}px`;
        column.style.setProperty("--bottom-height", heightPx);
      }

      fetchWeather().then(() => {
        const svgs = document.querySelectorAll("svg");

        /**
         * @returns {void}
         */
        function animateSVGs() {
          svgs.forEach((svg) => {
            svg.animate(
              [
                { transform: "scale(1)" },
                { transform: "scale(1.1)" },
                { transform: "scale(1)" },
              ],
              {
                duration: 200,
                easing: "ease-in-out",
              },
            );
          });

          if (document.body.classList.contains("show-last-weather")) {
            document.body.classList.remove("show-last-weather");
            document.body.classList.add("show-next-weather");
          } else if (document.body.classList.contains("show-next-weather")) {
            document.body.classList.remove("show-next-weather");
            document.body.classList.add("show-last-weather");
          } else {
            document.body.classList.add("show-last-weather");
          }
        }

        window.addEventListener("pointerdown", animateSVGs);
        window.addEventListener("keydown", animateSVGs);
      });

      const RAIN_TIMELINE_OFFSET = 6;

      fetchCurrentWeather().then((hourlyData) => {
        const currentHour = new Date().getHours();
        const currentWeatherCode = hourlyData.weather_code[currentHour];
        const currentTemperature = hourlyData.temperature_2m[currentHour];

        console.log(
          `Current weather code: ${currentWeatherCode}, temperature: ${currentTemperature}°C`,
        );

        console.log(
          `Current weather code: ${currentWeatherCode}, temperature: ${currentTemperature}°C`,
        );

        const weatherType = Object.keys(weatherTypes).find((key) =>
          weatherTypes[key].codes.includes(currentWeatherCode),
        );

        console.log(`Current weather type: ${weatherType}`);

        const currentWeatherElem = document.getElementById("current-weather");
        if (!currentWeatherElem) {
          console.warn("[Weather] Element with ID 'current-weather' not found");
          return;
        }

        const weatherSvg = document.querySelector(`svg#${weatherType}`);

        if (!weatherSvg) {
          console.warn(
            `[Weather] SVG element for weather type '${weatherType}' not found`,
          );
          return;
        }

        const currentWeatherSvg = currentWeatherElem.querySelector(
          "svg#current-weather-icon",
        );
        if (!currentWeatherSvg) {
          console.warn(
            "[Weather] No SVG found inside 'currentWeather' element",
          );
          return;
        }

        currentWeatherSvg.outerHTML = weatherSvg.outerHTML;

        const currentWeatherTemp = document.getElementById(
          "current-temp-content",
        );
        if (!currentWeatherTemp) {
          console.warn(
            "[Weather] Element with ID 'current-temp-content' not found",
          );
          return;
        }

        currentWeatherTemp.textContent = currentTemperature.toString();

        currentWeatherElem.style.display = "inherit";

        const rainTimeline = document.getElementById("rain-timeline");
        if (!rainTimeline) {
          console.warn("[Weather] Element with ID 'rain-timeline' not found");
          return;
        }

        console.log(`Setting current hour position to ${currentHour}`);

        const currentHourPosition = Math.max(
          Math.min(currentHour - RAIN_TIMELINE_OFFSET, 16),
          0,
        ); // since our timeline starts at 6am

        rainTimeline.style.setProperty(
          "--hour-position",
          currentHourPosition.toString(),
        );

        // Select all elements with the class .column
        document
          .querySelectorAll(".column")
          .forEach((/** @type{HTMLElement} */ el) => {
            const index = parseInt(el.dataset.index || "", 10);

            // If data-index is lower than --hour-position, set opacity to 0.5
            if (index < currentHourPosition + RAIN_TIMELINE_OFFSET) {
              el.style.opacity = "0.5";
            }
          });

        const todayRainTimelineData = hourlyData.rain;
        console.debug("Today's rain timeline data:", todayRainTimelineData);

        const noRain = todayRainTimelineData.every((rain) => rain === 0);
        if (noRain) {
          console.log("No rain expected today, hiding rain timeline");
          return;
        }

        rainTimeline.style.visibility = "visible";

        const maxRain = Math.max(...todayRainTimelineData);
        const HEAVY_RAIN_THRESHOLD = 2;

        const heaviness_offset = Math.min(1, maxRain / HEAVY_RAIN_THRESHOLD);

        console.debug("Max rain value for today:", maxRain);

        todayRainTimelineData.forEach((rain, index) => {
          setBottomBar(index, Math.min((rain / maxRain) * heaviness_offset, 1));
        });

        const todayCloudTimelineData = hourlyData.cloud_cover_low.map(
          (low, index) =>
            Math.max(
              low,
              hourlyData.cloud_cover_mid[index],
              hourlyData.cloud_cover_high[index],
            ),
        );

        console.debug("Today's cloud timeline data:", todayCloudTimelineData);

        const noClouds = todayCloudTimelineData.every((cloud) => cloud === 0);

        if (noClouds) {
          console.log("No clouds expected today");
          return;
        }

        todayCloudTimelineData.forEach((cloud, index) => {
          setTopBar(index, cloud / 100);
        });
      });
    </script>
  </body>
</html>
